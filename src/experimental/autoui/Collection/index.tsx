import React from 'react';

import { JSONSchema7 as JSONSchema } from 'json-schema';
import size from 'lodash/size';
import intersectionBy from 'lodash/intersectionBy';
import { TFunction } from 'i18next';

// TODO: Bring everything as part of autoUI once all collections with tags are replaced

import { Lenses, CollectionLenses } from './Lenses';
import { Tags } from './Tags';
import { Create } from './Actions/Create';
import { Filters } from './Filters';
import { Update } from './Actions/Update';
import { List } from './List';

import {
	AutoUIAction,
	AutoUIContext,
	AutoUIModel,
	BaseResource,
	getFieldForFormat,
} from '../schemaOps';
import styled from 'styled-components';
// import { NoRecordsFoundArrow } from '~/components/NoRecordsFoundArrow';

import { Flex } from '~/components/Flex';
import { ResourceTagModelService, submitResourceTags } from '../Tags/tag-management-service';
import { ResourceTagInfo } from '../Tags/models';
import { notifications } from '~/components/Notifications';
import { Spinner } from '~/components/Spinner';
import { Box } from '~/components/Box';
import { Dictionary } from 'lodash';
import { getFromLocalStorage, setToLocalStorage } from '~/components/Table/TableUtils';
import { filter } from '~/components/Filters/SchemaSieve';

// Assumptions that I think we can easily make:
// We only handle a single-level schema. If a schema is nested, it is handled by the `format` component internally.

// TODO:
// In rendition if there is an existing notification with a certain ID when submitting a new one, replace it with the new one.
// Move tableWithCustomColumns to rendition
// Make the Table JSON-schema compliant
// Implement sort functions per format
// 1-to-1 relationships should resolve as an object, not an array with one item (eg is_for__device_type should be an object when expanded).
// One to many relationships can be both a number (when using $count) and an array of objects, pine should return counts as part of an object instead (eg. always return an object with __count, and data: []). This can generalize for any field, if we find a `__count` we can render the count instead. Maybe handle this as a format, so it will handle both numbers and arrays? I guess this will be the smallest shape of a collection summary.
// Make table handle tags better so we don't have to filter it out from the schema.
// Specifically for the table, how should we treat columns that are based on multiple schema fields, shall we have some rule around that? Eg. the release "deployment" column combines "status" and "source" and it does appear more compact than having a separate column just to say it is a cloud build or a balena deploy one.
// How shall we handle batch edits (especially when the data differs between entries)? We already do this for HUP but it is all custom code, we need to generalize it.
// SDK's CRUD should all have the same function signature (eg. apiKey.create doesnt take a single object, but two separate fields).

const HeaderGrid = styled(Flex)`
	margin-left: -4px;
	margin-right: -4px;

	> * {
		margin-left: 4px;
		margin-right: 4px;
	}
`;

const getSelectedItems = <T extends BaseResource<T>>(
	newItems: T[],
	selectedItems: T[],
) => {
	if (!size(selectedItems)) {
		return selectedItems;
	}
	// update the selections
	selectedItems = intersectionBy(newItems, selectedItems, 'id');
	return selectedItems;
};

export interface ActionData<T> {
	action: AutoUIAction<T>;
	schema: JSONSchema;
	affectedEntries?: T[];
}

export const Collection = <T extends BaseResource<T>>({
	model,
	data,
	actions,
	sdk,
	customSort,
	cardRenderer,
	getBaseUrl,
	onRowClick,
	t,
}: {
	model: AutoUIModel<T>;
	data: T[] | undefined;
	actions?: Array<AutoUIAction<T>>;
	sdk?: {
		tags?: ResourceTagModelService;
		refresh?: () => void;
	};
	customSort?: Dictionary<(a: T, b: T) => void>;
	cardRenderer?: AutoUIContext<T>['cardRenderer'];
	// TODO: Ideally the base URL is autogenerated, but there are some issues with that currently (eg. instead of application we have apps in the URL)
	getBaseUrl?: (entry: T) => string;
	onRowClick?: (
		entry: T,
		event: React.MouseEvent<HTMLAnchorElement, MouseEvent>,
	) => void;
	t: TFunction;
}) => {
	const defaultLens = !!cardRenderer
		? CollectionLenses.Grid
		: CollectionLenses.Table;
	const [lens, setLens] = React.useState(
		getFromLocalStorage(`${model.resource}__view_lens`) ?? defaultLens,
	);
	const [filters, setFilters] = React.useState<JSONSchema[]>([]);
	const [selected, setSelected] = React.useState<T[]>([]);
	const [isBusyMessage, setIsBusyMessage] = React.useState<
		string | undefined
	>();
	const [actionData, setActionData] = React.useState<
		ActionData<T> | undefined
	>();

	const showFilters = !!(data?.length && data.length > 5);
	const showActions = !!data?.length;

	const autouiContext = React.useMemo(
		() =>
			({
				resource: model.resource,
				idField: 'id',
				nameField: model.priorities?.primary[0] ?? 'id',
				tagField: getFieldForFormat(model.schema, 'tag'),
				getBaseUrl,
				onRowClick,
				actions,
				cardRenderer,
				customSort,
			} as AutoUIContext<T>),
		[model, actions, cardRenderer],
	);

	const filtered = React.useMemo(
		() => (data ? filter(filters, data) : []) as T[],
		[data, filters],
	);

	React.useEffect(() => {
		setSelected((oldSelected) => getSelectedItems(oldSelected, filtered));
	}, [filtered]);

	const changeTags = React.useCallback(
		async (tags: Array<ResourceTagInfo<T>>) => {
			if (!sdk?.tags) {
				return;
			}

			setIsBusyMessage(t(`loading.updating_release_tags`));
			notifications.addNotification({
				id: 'change-tags-loading',
				content: t(`loading.updating_release_tags`),
			});

			try {
				await submitResourceTags(sdk.tags, tags);
				setSelected([]);
				notifications.addNotification({
					id: 'change-tags',
					content: 'Tags updated successfully',
					type: 'success',
				});
				sdk.refresh?.();
			} catch (err) {
				notifications.addNotification({
					id: 'change-tags',
					content: err.message,
					type: 'danger',
				});
			} finally {
				notifications.removeNotification('change-tags-loading');
				setIsBusyMessage(undefined);
			}
		},
		[sdk?.tags, sdk?.refresh],
	);

	const onActionTriggered = React.useCallback((actionData: ActionData<T>) => {
		setActionData(actionData);
	}, []);

	const onActionDone = React.useCallback((isSuccessful: boolean) => {
		if (isSuccessful) {
			setSelected([]);
		}

		setActionData(undefined);
	}, []);

	const handleLensChange = (lens: CollectionLenses) => {
		setLens(lens);
		setToLocalStorage(`${model.resource}__view_lens`, lens);
	};

	return (
		<Flex flexDirection="column" mt={2}>
			<Spinner
				label={
					isBusyMessage ??
					t('loading.resource', {
						resource: t(`resource.${model.resource}_plural`).toLowerCase(),
					})
				}
				show={data == null || !!isBusyMessage}
			>
				<Box>
					<HeaderGrid flexWrap="wrap" justifyContent="space-between">
						<Create
							model={model}
							autouiContext={autouiContext}
							hasOngoingAction={false}
							onActionTriggered={onActionTriggered}
							t={t}
						/>
						<Box
							order={[-1, -1, -1, 0]}
							flex={['1 0 100%', '1 0 100%', '1 0 100%', 'auto']}
						>
							{showFilters && (
								<Filters
									schema={model.schema}
									filters={filters}
									autouiContext={autouiContext}
									changeFilters={setFilters}
								/>
							)}
						</Box>
						<HeaderGrid>
							{showActions && (
								<Tags
									t={t}
									autouiContext={autouiContext}
									selected={selected}
									changeTags={changeTags}
								/>
							)}
							{showActions && (
								<Update
									model={model}
									selected={selected}
									autouiContext={autouiContext}
									hasOngoingAction={false}
									onActionTriggered={onActionTriggered}
									t={t}
								/>
							)}
							<Lenses
								autouiContext={autouiContext}
								lens={lens}
								changeLens={handleLensChange}
							/>
						</HeaderGrid>
					</HeaderGrid>

					<Filters
						renderMode={'summary'}
						schema={model.schema}
						filters={filters}
						autouiContext={autouiContext}
						changeFilters={setFilters}
					/>
				</Box>

				{data && data.length === 0 && (
					<NoRecordsFoundArrow>
						{t(`no_data.no_resource_data`, {
							resource: t(`resource.${model.resource}_plural`).toLowerCase(),
						})}
						<br />
						{t('questions.how_about_adding_one')}
					</NoRecordsFoundArrow>
				)}

				{data && data.length > 0 && (
					<List
						schema={model.schema}
						priorities={model.priorities}
						autouiContext={autouiContext}
						data={data}
						lens={lens}
						selected={selected}
						filtered={filtered}
						changeSelected={setSelected}
					/>
				)}

				{actionData &&
					actionData.action.renderer({
						schema: actionData.schema,
						affectedEntries: actionData.affectedEntries,
						onDone: onActionDone,
					})}
			</Spinner>
		</Flex>
	);
};
